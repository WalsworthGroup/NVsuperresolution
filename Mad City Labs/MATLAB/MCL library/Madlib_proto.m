function [methodinfo,structs,enuminfo,ThunkLibName]=Madlib_proto
%MADLIB_PROTO Create structures to define interfaces found in 'Madlib'.

%This function was generated by loadlibrary.m parser version  on Fri Sep 15 15:01:40 2023
%perl options:'Madlib.i -outfile=Madlib_proto.m -thunkfile=Madlib_thunk_pcwin64.c -header=Madlib.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'Madlib_thunk_pcwin64');
%  void MCL_DLLVersion ( short * version , short * revision ); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrThunk';fcns.name{fcnNum}='MCL_DLLVersion'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'int16Ptr', 'int16Ptr'};fcnNum=fcnNum+1;
%  int MCL_InitHandle (); 
fcns.thunkname{fcnNum}='int32Thunk';fcns.name{fcnNum}='MCL_InitHandle'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  int MCL_GrabHandle ( short device ); 
fcns.thunkname{fcnNum}='int32int16Thunk';fcns.name{fcnNum}='MCL_GrabHandle'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
%  int MCL_InitHandleOrGetExisting (); 
fcns.thunkname{fcnNum}='int32Thunk';fcns.name{fcnNum}='MCL_InitHandleOrGetExisting'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  int MCL_GrabHandleOrGetExisting ( short device ); 
fcns.thunkname{fcnNum}='int32int16Thunk';fcns.name{fcnNum}='MCL_GrabHandleOrGetExisting'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
%  int MCL_GetHandleBySerial ( short serial ); 
fcns.thunkname{fcnNum}='int32int16Thunk';fcns.name{fcnNum}='MCL_GetHandleBySerial'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
%  int MCL_GrabAllHandles (); 
fcns.thunkname{fcnNum}='int32Thunk';fcns.name{fcnNum}='MCL_GrabAllHandles'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  int MCL_GetAllHandles ( int * handles , int size ); 
fcns.thunkname{fcnNum}='int32voidPtrint32Thunk';fcns.name{fcnNum}='MCL_GetAllHandles'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32Ptr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_NumberOfCurrentHandles (); 
fcns.thunkname{fcnNum}='int32Thunk';fcns.name{fcnNum}='MCL_NumberOfCurrentHandles'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  void MCL_ReleaseHandle ( int handle ); 
fcns.thunkname{fcnNum}='voidint32Thunk';fcns.name{fcnNum}='MCL_ReleaseHandle'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  void MCL_ReleaseAllHandles (); 
fcns.thunkname{fcnNum}='voidThunk';fcns.name{fcnNum}='MCL_ReleaseAllHandles'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  double MCL_SingleReadZ ( int handle ); 
fcns.thunkname{fcnNum}='doubleint32Thunk';fcns.name{fcnNum}='MCL_SingleReadZ'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  double MCL_SingleReadN ( unsigned int axis , int handle ); 
fcns.thunkname{fcnNum}='doubleuint32int32Thunk';fcns.name{fcnNum}='MCL_SingleReadN'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'uint32', 'int32'};fcnNum=fcnNum+1;
%  int MCL_SingleWriteZ ( double position , int handle ); 
fcns.thunkname{fcnNum}='int32doubleint32Thunk';fcns.name{fcnNum}='MCL_SingleWriteZ'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'double', 'int32'};fcnNum=fcnNum+1;
%  int MCL_SingleWriteN ( double position , unsigned int axis , int handle ); 
fcns.thunkname{fcnNum}='int32doubleuint32int32Thunk';fcns.name{fcnNum}='MCL_SingleWriteN'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'double', 'uint32', 'int32'};fcnNum=fcnNum+1;
%  double MCL_MonitorZ ( double position , int handle ); 
fcns.thunkname{fcnNum}='doubledoubleint32Thunk';fcns.name{fcnNum}='MCL_MonitorZ'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'double', 'int32'};fcnNum=fcnNum+1;
%  double MCL_MonitorN ( double position , unsigned int axis , int handle ); 
fcns.thunkname{fcnNum}='doubledoubleuint32int32Thunk';fcns.name{fcnNum}='MCL_MonitorN'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'double', 'uint32', 'int32'};fcnNum=fcnNum+1;
%  double MCL_ReadEncoderZ ( int handle ); 
fcns.thunkname{fcnNum}='doubleint32Thunk';fcns.name{fcnNum}='MCL_ReadEncoderZ'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_ResetEncoderZ ( int handle ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='MCL_ResetEncoderZ'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_ThetaX ( double milliradians , double * actual , int handle ); 
fcns.thunkname{fcnNum}='int32doublevoidPtrint32Thunk';fcns.name{fcnNum}='MCL_ThetaX'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'double', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_ThetaY ( double milliradians , double * actual , int handle ); 
fcns.thunkname{fcnNum}='int32doublevoidPtrint32Thunk';fcns.name{fcnNum}='MCL_ThetaY'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'double', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_MoveZCenter ( double position , double * actual , int handle ); 
fcns.thunkname{fcnNum}='int32doublevoidPtrint32Thunk';fcns.name{fcnNum}='MCL_MoveZCenter'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'double', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_LevelZ ( double position , int handle ); 
fcns.thunkname{fcnNum}='int32doubleint32Thunk';fcns.name{fcnNum}='MCL_LevelZ'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'double', 'int32'};fcnNum=fcnNum+1;
%  int MCL_CFocusSetFocusMode ( bool focusModeOn , int handle ); 
fcns.thunkname{fcnNum}='int32uint8int32Thunk';fcns.name{fcnNum}='MCL_CFocusSetFocusMode'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'uint8', 'int32'};fcnNum=fcnNum+1;
%  int MCL_CFocusStep ( double relativePositionChange , int handle ); 
fcns.thunkname{fcnNum}='int32doubleint32Thunk';fcns.name{fcnNum}='MCL_CFocusStep'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'double', 'int32'};fcnNum=fcnNum+1;
%  int MCL_CFocusGetFocusMode ( int * focusLocked , int handle ); 
fcns.thunkname{fcnNum}='int32voidPtrint32Thunk';fcns.name{fcnNum}='MCL_CFocusGetFocusMode'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32Ptr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_ReadWaveFormN ( unsigned int axis , unsigned int DataPoints , double milliseconds , double * waveform , int handle ); 
fcns.thunkname{fcnNum}='int32uint32uint32doublevoidPtrint32Thunk';fcns.name{fcnNum}='MCL_ReadWaveFormN'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'uint32', 'uint32', 'double', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_Setup_ReadWaveFormN ( unsigned int axis , unsigned int DataPoints , double milliseconds , int handle ); 
fcns.thunkname{fcnNum}='int32uint32uint32doubleint32Thunk';fcns.name{fcnNum}='MCL_Setup_ReadWaveFormN'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'uint32', 'uint32', 'double', 'int32'};fcnNum=fcnNum+1;
%  int MCL_Trigger_ReadWaveFormN ( unsigned int axis , unsigned int DataPoints , double * waveform , int handle ); 
fcns.thunkname{fcnNum}='int32uint32uint32voidPtrint32Thunk';fcns.name{fcnNum}='MCL_Trigger_ReadWaveFormN'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'uint32', 'uint32', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_LoadWaveFormN ( unsigned int axis , unsigned int DataPoints , double milliseconds , double * waveform , int handle ); 
fcns.thunkname{fcnNum}='int32uint32uint32doublevoidPtrint32Thunk';fcns.name{fcnNum}='MCL_LoadWaveFormN'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'uint32', 'uint32', 'double', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_Setup_LoadWaveFormN ( unsigned int axis , unsigned int DataPoints , double milliseconds , double * waveform , int handle ); 
fcns.thunkname{fcnNum}='int32uint32uint32doublevoidPtrint32Thunk';fcns.name{fcnNum}='MCL_Setup_LoadWaveFormN'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'uint32', 'uint32', 'double', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_Trigger_LoadWaveFormN ( unsigned int axis , int handle ); 
fcns.thunkname{fcnNum}='int32uint32int32Thunk';fcns.name{fcnNum}='MCL_Trigger_LoadWaveFormN'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'uint32', 'int32'};fcnNum=fcnNum+1;
%  int MCL_TriggerWaveformAcquisition ( unsigned int axis , unsigned int DataPoints , double * waveform , int handle ); 
fcns.thunkname{fcnNum}='int32uint32uint32voidPtrint32Thunk';fcns.name{fcnNum}='MCL_TriggerWaveformAcquisition'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'uint32', 'uint32', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_WfmaSetup ( double * wfDacX , double * wfDacY , double * wfDacZ , int dataPointsPerAxis , double milliseconds , unsigned short iterations , int handle ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrint32doubleuint16int32Thunk';fcns.name{fcnNum}='MCL_WfmaSetup'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'doublePtr', 'int32', 'double', 'uint16', 'int32'};fcnNum=fcnNum+1;
%  int MCL_WfmaTriggerAndRead ( double * wfAdcX , double * wfAdcY , double * wfAdcZ , int handle ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='MCL_WfmaTriggerAndRead'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_WfmaTrigger ( int handle ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='MCL_WfmaTrigger'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_WfmaRead ( double * wfAdcX , double * wfAdcY , double * wfAdcZ , int handle ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='MCL_WfmaRead'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_WfmaStop ( int handle ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='MCL_WfmaStop'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_IssBindClockToAxis ( int clock , int mode , int axis , int handle ); 
fcns.thunkname{fcnNum}='int32int32int32int32int32Thunk';fcns.name{fcnNum}='MCL_IssBindClockToAxis'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'int32', 'int32', 'int32'};fcnNum=fcnNum+1;
%  int MCL_IssConfigurePolarity ( int clock , int mode , int handle ); 
fcns.thunkname{fcnNum}='int32int32int32int32Thunk';fcns.name{fcnNum}='MCL_IssConfigurePolarity'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'int32', 'int32'};fcnNum=fcnNum+1;
%  int MCL_IssSetClock ( int clock , int mode , int handle ); 
fcns.thunkname{fcnNum}='int32int32int32int32Thunk';fcns.name{fcnNum}='MCL_IssSetClock'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'int32', 'int32'};fcnNum=fcnNum+1;
%  int MCL_IssResetDefaults ( int handle ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='MCL_IssResetDefaults'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_ChangeClock ( double milliseconds , short clock , int handle ); 
fcns.thunkname{fcnNum}='int32doubleint16int32Thunk';fcns.name{fcnNum}='MCL_ChangeClock'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'double', 'int16', 'int32'};fcnNum=fcnNum+1;
%  int MCL_PixelClock ( int handle ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='MCL_PixelClock'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_LineClock ( int handle ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='MCL_LineClock'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_FrameClock ( int handle ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='MCL_FrameClock'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_AuxClock ( int handle ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='MCL_AuxClock'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_GetClockFrequency ( double * adcfreq , double * dacfreq , int handle ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='MCL_GetClockFrequency'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_SequenceLoad ( int axis , double * sequence , int seqSize , int handle ); 
fcns.thunkname{fcnNum}='int32int32voidPtrint32int32Thunk';fcns.name{fcnNum}='MCL_SequenceLoad'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'doublePtr', 'int32', 'int32'};fcnNum=fcnNum+1;
%  int MCL_SequenceClear ( int handle ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='MCL_SequenceClear'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_SequenceStart ( int handle ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='MCL_SequenceStart'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_SequenceStop ( int handle ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='MCL_SequenceStop'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_SequenceGetMax ( int * max , int handle ); 
fcns.thunkname{fcnNum}='int32voidPtrint32Thunk';fcns.name{fcnNum}='MCL_SequenceGetMax'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32Ptr', 'int32'};fcnNum=fcnNum+1;
%  double MCL_GetCalibration ( unsigned int axis , int handle ); 
fcns.thunkname{fcnNum}='doubleuint32int32Thunk';fcns.name{fcnNum}='MCL_GetCalibration'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'uint32', 'int32'};fcnNum=fcnNum+1;
%  double MCL_TipTiltHeight ( int handle ); 
fcns.thunkname{fcnNum}='doubleint32Thunk';fcns.name{fcnNum}='MCL_TipTiltHeight'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  double MCL_TipTiltWidth ( int handle ); 
fcns.thunkname{fcnNum}='doubleint32Thunk';fcns.name{fcnNum}='MCL_TipTiltWidth'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_MinMaxThetaX ( double * min , double * max , int handle ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='MCL_MinMaxThetaX'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_MinMaxThetaY ( double * min , double * max , int handle ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='MCL_MinMaxThetaY'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  double MCL_GetTipTiltThetaX ( int handle ); 
fcns.thunkname{fcnNum}='doubleint32Thunk';fcns.name{fcnNum}='MCL_GetTipTiltThetaX'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  double MCL_GetTipTiltThetaY ( int handle ); 
fcns.thunkname{fcnNum}='doubleint32Thunk';fcns.name{fcnNum}='MCL_GetTipTiltThetaY'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  double MCL_GetTipTiltCenter ( int handle ); 
fcns.thunkname{fcnNum}='doubleint32Thunk';fcns.name{fcnNum}='MCL_GetTipTiltCenter'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_CurrentMinMaxThetaX ( double * min , double * max , int handle ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='MCL_CurrentMinMaxThetaX'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_CurrentMinMaxThetaY ( double * min , double * max , int handle ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='MCL_CurrentMinMaxThetaY'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_CurrentMinMaxCenter ( double * min , double * max , int handle ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='MCL_CurrentMinMaxCenter'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_GetFirmwareVersion ( short * version , short * profile , int handle ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='MCL_GetFirmwareVersion'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int16Ptr', 'int16Ptr', 'int32'};fcnNum=fcnNum+1;
%  int MCL_GetSerialNumber ( int handle ); 
fcns.thunkname{fcnNum}='int32int32Thunk';fcns.name{fcnNum}='MCL_GetSerialNumber'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  int MCL_GetProductInfo ( struct ProductInformation * pi , int handle ); 
fcns.thunkname{fcnNum}='int32voidPtrint32Thunk';fcns.name{fcnNum}='MCL_GetProductInfo'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'ProductInformationPtr', 'int32'};fcnNum=fcnNum+1;
%  void MCL_PrintDeviceInfo ( int handle ); 
fcns.thunkname{fcnNum}='voidint32Thunk';fcns.name{fcnNum}='MCL_PrintDeviceInfo'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'int32'};fcnNum=fcnNum+1;
%  bool MCL_DeviceAttached ( int milliseconds , int handle ); 
fcns.thunkname{fcnNum}='uint8int32int32Thunk';fcns.name{fcnNum}='MCL_DeviceAttached'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint8'; fcns.RHS{fcnNum}={'int32', 'int32'};fcnNum=fcnNum+1;
%  bool MCL_CorrectDriverVersion (); 
fcns.thunkname{fcnNum}='uint8Thunk';fcns.name{fcnNum}='MCL_CorrectDriverVersion'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint8'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  int MCL_GetCommandedPosition ( double * xCom , double * yCom , double * zCom , int handle ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='MCL_GetCommandedPosition'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'doublePtr', 'int32'};fcnNum=fcnNum+1;
structs.ProductInformation.packing=1;
structs.ProductInformation.members=struct('axis_bitmap', 'uint8', 'ADC_resolution', 'int16', 'DAC_resolution', 'int16', 'Product_id', 'int16', 'FirmwareVersion', 'int16', 'FirmwareProfile', 'int16');
methodinfo=fcns;